{"pages":[{"title":"����","text":"","link":"/about/index.html"},{"title":"404 Page Not Found","text":"","link":"/404/404.html"},{"title":"����","text":"","link":"/scarch/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/09/04/hello-world/"},{"title":"小绿本","text":"IO多路复用的作用？以及实现机制 IO多路复用用于提升效率，单个进程可以同时监听多个网络连接IO。 例子： 通过一种机制，可以监视多个文件描述符，一旦描述符就绪（读写就绪），能通知程序进行相应的读写操作，IO多路复用就避免阻塞在io上，原本为多进程或多线程来接收多个连接的消息变为单进程或者单线程保存多个socket的状态后轮询处理。 select是通过系统调用来监视一组由多个文件描述组成的数组，通过调用select()返回结果，数组中就绪的文件描述符会被内核标记出来，然后进程就可以获得文件描述符，然后进行相应的读写操作。 每次调用select，都需要把fd集合由用户态拷贝到内核态，在fd多的时候开销会很大，每次select都是线性遍历整个列表，当fd很大的时候，遍历的开销也很大。 poll本质上和select基本相同，只不过监控的最大连接数上相较于seleect没有了限制，因为poll使用的数据结构是链表，而select使用的是数组，数组是要初始化长度大小的，且不能改变 epoll就解决了select和poll的本身的缺陷： 数组长度的解决方法：fd上限是最大可以打开文件的数目。 需要每次轮询将数组全部拷贝到内核态的解决方案：每次注册事件的时候，会把fd拷贝到内核态，而不是每次epoll的时候拷贝，这样就保证每个fd只需要拷贝一次。 每次 遍历都需要列表线性解决方案：不在采用遍历的方案，给每个fd指定一个回调函数，fd就绪时，调用回调函数，这个回调函数就会I把fd加入到fd列表中，所以epoll需要遍历就绪的list即可。 什么是防火墙？有什么作用？ 防火墙就是一种将内部网络和公网分开的一种方法。 作用： 入侵检测功能：防木马，蠕虫，缓冲区溢出 网络地址转换（NAT）功能：实现内地址与外网地址的转换 网络操作中的审计监控功能 强化网络安全服务 threading.local()的作用？ threading.local()这个方法的特点用来保存一个全局变量，但是这个全局变量只有在当前线程才能访问，如果你在开发多线程应用的时候 需要每个线程保存一个单独的数据供当前线程操作，可以考虑使用这个方法，简单有效。举例：每个子线程使用全局对象a，但每个线程定义的属性a.xx是该线程独有的，Python提供了 threading.local 类，将这个类实例化得到一个全局对象，但是不同的线程使用这个对象存储的数据其它线程不可见(本质上就是不同的线程使用这个对象时为其创建一个独立的字典)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#coding=utf-8import threading# 创建全局ThreadLocal对象:localVal = threading.local()localVal.val = &quot;Main-Thread&quot;def process_student(): print &apos;%s (in %s)&apos; % (localVal.val, threading.current_thread().name)def process_thread(name): #赋值 localVal.val = name process_student()t1 = threading.Thread(target= process_thread, args=(&apos;One&apos;,), name=&apos;Thread-A&apos;)t2 = threading.Thread(target= process_thread, args=(&apos;Two&apos;,), name=&apos;Thread-B&apos;)t1.start()t2.start()t1.join()t2.join()print localVal.val打印结果：One (in Thread-A)Two (in Thread-B)Main-Threadthreading.local()这个方法的特点用来保存一个全局变量，但是这个全局变量只有在当前线程才能访问，localVal.val = name这条语句可以储存一个变量到当前线程，如果在另外一个线程里面再次对localVal.val进行赋值，那么会在另外一个线程单独创建内存空间来存储，也就是说在不同的线程里面赋值 不会覆盖之前的值，因为每个线程里面都有一个单独的空间来保存这个数据,而且这个数据是隔离的，其他线程无法访问这个东西可以用在那些地方呢，比如下载，现在都是多线程下载了，就像酷狗那样，可以同时下载很多首歌曲，那么就可以利用这个方法来保存每个下载线程的数据，比如下载进度，下载速度之类的所以 如果你在开发多线程应用的时候 需要每个线程保存一个单独的数据供当前线程操作，可以考虑使用这个方法，简单有效其实这样的功能还有很多种方法可以实现，比如我们在主线程实例化一个dict对象，然后用线程的名字作为key，因为线程之间可以共享数据，所以也可以实现相同功能，并且灵活性更多，不过代码就没那么优雅简洁了 什么是cdn？ CDN全称Content Deliverey Network即内容分发网络，CDN是现有网络基础之上的智能虚拟网络，依靠在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就进获取所需的内容，降低网络阻塞，提高用户访问响应的速度和命中率。CDN的关键技术就是内容储存和分发技术。 什么是Twisted框架？ Twisted是一个事件驱动型的网络模型，事件驱动模型编程是一种规范，这里程序的执行流由外部决定。特点是：包涵一个事件循环，当外部事件发生时 ，使用回调机制来触发相应的处理。 什么是LVS？ LVS是linux VIrtual Server的简写，意思就是Linux虚拟服务器，是一个虚拟的服务器集群系统，就是使用集群技术和linux操作系统实现一个高性能、高可用的服务器。 什么是haproxy？ HaProxy是一种使用C语言编写的自由及开放源代码的软件，其提供高可用性、负载均衡，以及基于TCP和Http的应用程序代理。 1234HAProxy是一个使用C语言编写的自由及开放源代码软件[1]，其提供高可用性、负载均衡，以及基于TCP和HTTP的应用程序代理。HAProxy特别适用于那些负载特大的web站点，这些站点通常又需要会话保持或七层处理。HAProxy运行在当前的硬件上，完全可以支持数以万计的并发连接。并且它的运行模式使得它可以很简单安全的整合进您当前的架构中， 同时可以保护你的web服务器不被暴露到网络上。HAProxy实现了一种事件驱动, 单一进程模型，此模型支持非常大的并发连接数。多进程或多线程模型受内存限制 、系统调度器限制以及无处不在的锁限制，很少能处理数千并发连接。事件驱动模型因为在有更好的资源和时间管理的用户空间(User-Space) 实现所有这些任务，所以没有这些问题。此模型的弊端是，在多核系统上，这些程序通常扩展性较差。这就是为什么他们必须进行优化以 使每个CPU时间片(Cycle)做更多的工作。包括 GitHub、Bitbucket[3]、Stack Overflow[4]、Reddit、Tumblr、Twitter[5][6]和 Tuenti[7]在内的知名网站，及亚马逊网络服务系统都使用了HAProxy。 [1] 什么是负载均衡 负载均衡建立在现有的网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽，增加吞吐量，加强网络数据处理能力，提高网络的灵活性和可用性。负载均衡其意思就是分摊到多个操作单元上进行执行，类如WEB服务器，FTP服务器，企业关键应用服务器和其他关键服务器，从而共同完成工作任务。 什么是rpc以及应用场景 RPC全程Remote Procedure Call,意为：远程过程调用，目前，主流的平台都支持各种远程调用技术，以满足分布式系统架构中不同的系统之间的的远程通信和相互调用。 1234567891011121314互联网时代常见的RPC技术和框架应用级的服务框架：Dubbo/DubboxZeroICEGRpcSpring Boot/Spring Cloud基础通信框架：Protocol BuffersThrift远程通信协议：RMISocketSOAP(HTTP XML)REST(HTTP JSON) 什么是反向代理和正向代理 什么是代理服务器？提供代理服务的电脑系统或其他类型的网络终端，代替网络用户去取得网络信息。 为什么使用代理服务器？提高访问速度（因为目标主机返回的税局存放在代理服务器的硬盘中，因此下一次客户再访问相同的站点数据时，会直接从代理服务器的硬盘中读取，起到了缓存的作用，尤其对于热门网站能明显提高访问速度）、防火墙的作用（由于所有的客户机请求都需要通过代理服务器访问远端的站点，因此可以在代理服务器上设置权限，过滤掉某些不安全信息。）突破访问限制（互联网上许多开发的代理服务器，客户机在访问受限时，可通过不受限制的代理服务器访问目标站点，通俗的说：我们使用的翻墙浏览器就是利用代理服务器，可以直接访问外网） 123456789101112131415161718192021222324252627282930313233343536正向代理 正向代理（forward proxy） ，一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理。 简单一点：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色。 反向代理 反向代理（Reverse Proxy），以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器。 理解起来有些抽象，可以这么说：A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在。 正向代理和反向代理的区别位置不同 正向代理，架设在客户机和目标主机之间； 反向代理，架设在服务器端；代理对象不同 正向代理，代理客户端，服务端不知道实际发起请求的客户端； 反向代理，代理服务端，客户端不知道实际提供服务的服务端； 备注：正向代理–HTTP代理为多个人提供翻墙服务；反向代理–百度外卖为多个商户提供平台给某个用户提供外卖服务。用途不同 正向代理，为在防火墙内的局域网客户端提供访问Internet的途径； 反向代理，将防火墙后面的服务器提供给Internet访问；安全性不同 正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此必须采取安全措施以确保仅为授权的客户端提供服务； 反向代理都对外都是透明的，访问者并不知道自己访问的是哪一个代理。正向代理的应用 1. 访问原来无法访问的资源 2. 用作缓存，加速访问速度 3. 对客户端访问授权，上网进行认证 4. 代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息反向代理的应用 1. 保护内网安全 2. 负载均衡 3. 缓存，减少服务器的压力 Nginx作为最近较火的反向代理服务器，安装在目的主机端，主要用于转发客户机请求，后台有多个http服务器提供服务，nginx的功能就是把请求转发给后台的服务器，决定哪台目标主机来处理当前请求。 正向代理是客户端的角度出发，服务特定的用户（比如局域网内的可以），以访问非特定的服务；反向代理正好相反，从服务端的角度出发，服务于非特定用户（通常是所有用户），以访问特定的服务。","link":"/2019/09/06/小绿本_网络编程/"}],"tags":[],"categories":[]}